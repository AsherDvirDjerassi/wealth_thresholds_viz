dynamic_df[paste(yr,sep=""),paste("Annual growth rate -", sep = " ", varName)] <-
non_dynamic_df[paste(yr+3,sep=""),paste("Three year growth rate -", sep = " ", varName)]^(1/3)
dynamic_df[paste(yr+1,sep=""),paste("Annual growth rate -", sep = " ", varName)] <-
non_dynamic_df[paste(yr+3,sep=""),paste("Three year growth rate -", sep = " ", varName)]^(1/3)
dynamic_df[paste(yr+2,sep=""),paste("Annual growth rate -", sep = " ", varName)] <-
non_dynamic_df[paste(yr+3,sep=""),paste("Three year growth rate -", sep = " ", varName)]^(1/3)
}
}
# b) Taxable Wealth Before and After Tax
for (yr in seq(1989,2019)) {
if(yr == 1989){
dynamic_df[paste(yr,sep=""),"Observed Taxable Wealth (annualized)"] <-
non_dynamic_df[paste(yr,sep=""),"Taxable Wealth"]
dynamic_df[paste(yr,sep=""),"Observed Non-Taxable Wealth (annualized)"] <-
non_dynamic_df[paste(yr,sep=""),"Non-Taxable Wealth"]
dynamic_df[paste(yr,sep=""),"Taxable Wealth Before Tax (simulated)"] <-
non_dynamic_df[paste(yr,sep=""),"Taxable Wealth"]
}
if(yr < 2019){
dynamic_df[paste(yr+1,sep=""),"Observed Taxable Wealth (annualized)"] <-
dynamic_df[paste(yr,sep=""),"Observed Taxable Wealth (annualized)"]*
dynamic_df[paste(yr,sep=""),"Annual growth rate - Taxable wealth"]
dynamic_df[paste(yr+1,sep=""),"Observed Non-Taxable Wealth (annualized)"] <-
dynamic_df[paste(yr,sep=""),"Observed Non-Taxable Wealth (annualized)"]*
dynamic_df[paste(yr,sep=""),"Annual growth rate - Non-Taxable wealth"]
## DOES THIS NEED TO BE ADJUSTED FOR INFLATION - HOW DOES THIS INTERACT WITH INFLATION ADFJUSTMENTS??
if(set_tax_rate == TRUE){
dynamic_df[paste(yr,sep=""),"Tax Rate"] <- tax_rate
}
if(set_tax_rate == FALSE){
dynamic_df[paste(yr,sep=""),"Tax Rate"] <-
dynamic_df[paste(yr,sep=""),"Total Revenue Required"]/
dynamic_df[paste(yr,sep=""),"Taxable Wealth Before Tax (simulated)"]
}
dynamic_df[paste(yr,sep=""),"Taxable Wealth After Tax (simulated)"] <-
dynamic_df[paste(yr,sep=""),"Taxable Wealth Before Tax (simulated)"]*
(1-dynamic_df[paste(yr,sep=""),"Tax Rate"])
if(yr < 2019){
dynamic_df[paste(yr+1,sep=""),"Taxable Wealth Before Tax (simulated)"] <-
dynamic_df[paste(yr,sep=""),"Taxable Wealth After Tax (simulated)"]*
dynamic_df[paste(yr,sep=""),"Annual growth rate - Taxable wealth"]
}
}
# c) Total wealth tax revenue
dynamic_df[,"Wealth Tax Revenue"] <-
dynamic_df[,"Taxable Wealth Before Tax (simulated)"] -
dynamic_df[,"Taxable Wealth After Tax (simulated)"]
# d) Cumulative Wealth Transfer
for (yr in seq(1989,2019)) {
if(yr == 1989){
dynamic_df[paste(yr,sep=""),"Cumulative Wealth Transfer"] <-
dynamic_df[paste(yr,sep=""),"Wealth Tax Revenue"]
} else {
dynamic_df[paste(yr,sep=""),"Cumulative Wealth Transfer"] <-
dynamic_df[paste(yr,sep=""),"Wealth Tax Revenue"] +
dynamic_df[paste(yr-1,sep=""),"Cumulative Wealth Transfer"]
}
}
# e) Cumulative Wealth Transfer and Appreciation
for (yr in seq(1989,2019)) {
if(yr == 1989){
dynamic_df[paste(yr,sep=""),"Cumulative Wealth Transfer and Appreciation"] <-
dynamic_df[paste(yr,sep=""),"Wealth Tax Revenue"]
} else {
dynamic_df[paste(yr,sep=""),"Cumulative Wealth Transfer and Appreciation"] <-
dynamic_df[paste(yr,sep=""),"Wealth Tax Revenue"] +
(dynamic_df[paste(yr-1,sep=""),"Cumulative Wealth Transfer"])*exp(r)
}
}
### MAKE THIS A FOR LOOP THAT ITERATES OVER THE TOP 10 TOP 1 BOTTOM 50 TAXABLE
#
varList <- list("Bottom 50%", "Top 10%", "Top 1%", "Taxable Households")
for(varName in List){
dynamic_df[paste("Post-tax Share -", varName, "(simulated)", "")] <-
}
for (yr in seq(1989,2019, 3)) {
varList <- c("Total Net Private Wealth","Taxable Wealth","Non-Taxable Wealth")
if(yr <= 2016){
for (varName in varList) {
dynamic_df[paste(yr,sep=""),paste("Annual growth rate -", sep = " ", varName)] <-
non_dynamic_df[paste(yr+3,sep=""),paste("Three year growth rate -", sep = " ", varName)]^(1/3)
dynamic_df[paste(yr+1,sep=""),paste("Annual growth rate -", sep = " ", varName)] <-
non_dynamic_df[paste(yr+3,sep=""),paste("Three year growth rate -", sep = " ", varName)]^(1/3)
dynamic_df[paste(yr+2,sep=""),paste("Annual growth rate -", sep = " ", varName)] <-
non_dynamic_df[paste(yr+3,sep=""),paste("Three year growth rate -", sep = " ", varName)]^(1/3)
}
}
}
dynamic_df[,"Taxable Wealth After Tax (simulated)"]/
dynamic_df[paste(yr,sep=""),"Observed Non-Taxable Wealth (annualized)"]
#################################
# Part 1) Non-dynamic Dataframe #
#################################
non_dynamic_df <- data.frame(matrix (nrow = 11, ncol = 0, byrow = 1))
rownames(non_dynamic_df) <- seq(1989,2019,3)
non_dynamic_df$Year <- rownames(non_dynamic_df)
yr
yr -1989
yr = 1989
# Generate temp df of scf for iterated year
df_temp <- subset(scf, scf$YEAR == yr)
set_total_revenue_required
rmarkdown:::find_pandoc()
pandoc_save_markdown(html, file = file, libdir = libdir,
background = background, title = title)
rmarkdown:::pandoc_save_markdown(html, file = file, libdir = libdir,
background = background, title = title)
rmarkdown::pandoc_save_markdown(html, file = file, libdir = libdir,
background = background, title = title)
find_pandoc()
install.packages("htmlwidgets", repos = "http://cran.us.r-project.org")
install.packages("htmlwidgets", repos = "http://cran.us.r-project.org")
library("htmlwidgets")
htmlwidgets::saveWidget(figure1, "figure1.html", selfcontained=TRUE)
figure1 <- highchart() %>%
hc_chart(type ="column",
barBorderWidth = 1) %>%
hc_title(text = "Figure 1: Wealth thresholds") %>%
hc_chart(zoomType = "x") %>%
hc_plotOptions(column = list(
dataLabels = list(enabled = FALSE),
stacking = "normal",
groupPadding = 0,
pointPadding = 0,
enableMouseTracking = TRUE)) %>%
hc_yAxis_multiples(
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = FALSE),
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = TRUE)) %>%
hc_xAxis(title = list(text = "Wealth Percentiles", style = list(fontSize = '13px')),
categories = df_quantiles$quantiles,
type = "category",
showFirstLabel = TRUE,
showLastLabel = TRUE
) %>%
hc_add_series(data = round(df_quantiles$Thresholds), name = "Wealth Thresholds", color = "grey", showInLegend = FALSE, visible = TRUE) %>%
hc_add_series(name = "<p style='font-size:15px; color:black'> Include Forbes 400 wealth threshold </p>", data = round(df_quantiles$`Forbes 400`), color = "red", showInLegend = TRUE, visible = FALSE,  fontSize = '200px') %>%
hc_legend(
align = "left",
verticalAlign = "top",
x = 75,
y = 0
) %>%
hc_exporting(enabled = TRUE) %>%
hc_tooltip(
useHTML = TRUE,
formatter = JS(
"
function(){
outHTML = '<b> Wealth Percentile: </b>' + this.x + '<br> <b> Threshold Value: </b>' + '$' + Number(this.y).toLocaleString()
return(outHTML)
}
"
),
shape = "callout", # Options are square, circle and callout
borderWidth = 1   # No border on the tooltip shape
)
# Authors: Asher Dvir-Djerassi and Fabian Pfeffer
# Date Began: 09/21/22
# Last Updated: 11/11/22
# Description: This program creates an interactive visualization that is exported as an HTML file.
# Data: 2019 Survey of Consumer Finances (SCF) public use file and the 2019 Forbes 400.
##############################################################################
################################### I. Set-up ################################
##############################################################################
#############################
#### Packages & Libraries ###
#############################
install.packages("haven", repos = "http://cran.us.r-project.org")
install.packages("formattable", repos = "http://cran.us.r-project.org")
library("formattable")
install.packages("ggplot2", repos = "http://cran.us.r-project.org")
library("ggplot2")
# The wrapper for highcharts, highcharter, imports most need packages in addition to being core to the visualizatio.
# Imported dependencies:	htmlwidgets, magrittr, purrr, rlist, assertthat, zoo, dplyr (≥ 1.0.0), tibble (≥ 1.1), stringr (≥ 1.3.0), broom, xts, quantmod, tidyr, htmltools, jsonlite, igraph, lubridate, yaml, rlang (≥ 0.1.1), rjson
install.packages("highcharter", repos = "http://cran.us.r-project.org")
library("highcharter") # For highcharter visualization
# Import the redlist, which is used for computing weighted statistics, included weighted quantiles.
# Imported dependencies: ps, processx, checkmate, matrixStats, callr, crayon, prettyunits, rprojroot, inline, gridExtra, loo, pkgbuild, desc, Rcpp, rstan, rstantools, BH, RcppArmadillo, RcppEigen, RcppParallel, StanHeaders, densEstBayes
install.packages("reldist", repos = "http://cran.us.r-project.org")
library("reldist")  #For computing weighted statistics
# Allows saving an HTML object to a file
install.packages("htmltools", repos = "http://cran.us.r-project.org")
library("htmltools")
install.packages("htmlwidgets", repos = "http://cran.us.r-project.org")
library("htmlwidgets")
#############################
#### Scientific Notation ####
#############################
options(scipen=999) # removes scientific notation from R output
##############################################################################
################################### II. Data #################################
##############################################################################
#############################
######### Load SCF ##########
#############################
# NOTE: Uncomment subsequent line to download raw data from Federal Reserve website.
# download.file("https://www.federalreserve.gov/econres/files/scfp2019excel.zip", "SCFP2019.zip")
scf <- read.csv(unzip("scfp2019.zip"), header = TRUE)
system("rm scfp2019.csv") # rm csv of scf
scf <- scf[c("NETWORTH","WGT")]
scf$YEAR <- 2019
#############################
##### Load Forbes 400  ######
#############################
# NOTE: Uncomment below to scrape and clean raw forbes 400 data for 2019.
# # scrape raw forbes 400 data for 2019
# forbes_400_2019 <- cbind.data.frame(jsonlite::fromJSON(paste0("http://www.forbes.com/ajax/list/data?year=", 2019, "&uri=forbes-400", "&type=person")),year= 2019)
# # rename variables
# colnames(forbes_400_2019)[colnames(forbes_400_2019) == "worth"] ="NETWORTH"
# colnames(forbes_400_2019)[colnames(forbes_400_2019) == "year"] ="YEAR"
# # create sample weights
# forbes_400_2019$WGT <- 1
# # transform networth value
# forbes_400_2019$NETWORTH <- forbes_400_2019$NETWORTH*1000000
# # keep subset of variables
# forbes_400_2019 <- forbes_400_2019[c("NETWORTH", "WGT", "YEAR")]
# # drop if na values for networth
# forbes_400_2019 <- na.omit(forbes_400_2019)
# # write csv
# write.csv(forbes_400_2019, "forbes_400_2019.csv", row.names = FALSE)
forbes_400 <- read.csv("forbes_400_2019.csv")
##############################################################################
####################### III. FIGURE - Wealth Thresholds ######################
##############################################################################
#############################
####### Data for Viz  #######
#############################
# number of households in net debt - referenced in text
comma(sum(subset(scf$WGT, scf$NETWORTH < 0)))
# create quantiles
df_quantiles <- data.frame(matrix (nrow = 100, ncol = 0, byrow = 1))
df_quantiles$quantiles <-  c(seq(1, 99, by = 1), "Forbes 400")
df_quantiles$quantiles[100] <- c("Forbes 400")
df_quantiles$"Forbes 400" <- 0
df_quantiles$"Forbes 400"[100] <- min(subset(forbes_400$NETWORTH, forbes_400$YEAR == 2019))
df_quantiles$Thresholds <-
c(wtd.quantile(scf$NETWORTH, seq(.01, .99, by = .01), weight = scf$WGT), NA)
#############################
#### Highcharter Options ####
#############################
options(highcharter.theme = hc_theme_smpl(tooltip = list(valueDecimals = 0, thousandsSep = ',')))
lang <- getOption("highcharter.lang")
lang$numericSymbols <- c(" Thousand"," Million"," Billion"," Trillion")
lang$thousandsSep <- ","
options(highcharter.lang = lang)
#############################
########## Figure 1 #########
#############################
figure1 <- highchart() %>%
hc_chart(type ="column",
barBorderWidth = 1) %>%
hc_title(text = "Figure 1: Wealth thresholds") %>%
hc_chart(zoomType = "x") %>%
hc_plotOptions(column = list(
dataLabels = list(enabled = FALSE),
stacking = "normal",
groupPadding = 0,
pointPadding = 0,
enableMouseTracking = TRUE)) %>%
hc_yAxis_multiples(
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = FALSE),
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = TRUE)) %>%
hc_xAxis(title = list(text = "Wealth Percentiles", style = list(fontSize = '13px')),
categories = df_quantiles$quantiles,
type = "category",
showFirstLabel = TRUE,
showLastLabel = TRUE
) %>%
hc_add_series(data = round(df_quantiles$Thresholds), name = "Wealth Thresholds", color = "grey", showInLegend = FALSE, visible = TRUE) %>%
hc_add_series(name = "<p style='font-size:15px; color:black'> Include Forbes 400 wealth threshold </p>", data = round(df_quantiles$`Forbes 400`), color = "red", showInLegend = TRUE, visible = FALSE,  fontSize = '200px') %>%
hc_legend(
align = "left",
verticalAlign = "top",
x = 75,
y = 0
) %>%
hc_exporting(enabled = TRUE) %>%
hc_tooltip(
useHTML = TRUE,
formatter = JS(
"
function(){
outHTML = '<b> Wealth Percentile: </b>' + this.x + '<br> <b> Threshold Value: </b>' + '$' + Number(this.y).toLocaleString()
return(outHTML)
}
"
),
shape = "callout", # Options are square, circle and callout
borderWidth = 1   # No border on the tooltip shape
)
saveWidget(figure1, "figure1.html", selfcontained=TRUE)
install.packages("htmltools", repos = "http://cran.us.r-project.org")
install.packages("htmlwidgets", repos = "http://cran.us.r-project.org")
options(scipen=999) # removes scientific notation from R output
# NOTE: Uncomment subsequent line to download raw data from Federal Reserve website.
# download.file("https://www.federalreserve.gov/econres/files/scfp2019excel.zip", "SCFP2019.zip")
scf <- read.csv(unzip("scfp2019.zip"), header = TRUE)
system("rm scfp2019.csv") # rm csv of scf
scf <- scf[c("NETWORTH","WGT")]
scf$YEAR <- 2019
forbes_400 <- read.csv("forbes_400_2019.csv")
read.csv("forbes_400_2019.csv")
setwd("~/Library/Mobile Documents/com~apple~CloudDocs/3.github/wealth_thresholds_viz")
forbes_400 <- read.csv("forbes_400_2019.csv")
# number of households in net debt - referenced in text
comma(sum(subset(scf$WGT, scf$NETWORTH < 0)))
# create quantiles
df_quantiles <- data.frame(matrix (nrow = 100, ncol = 0, byrow = 1))
df_quantiles$quantiles <-  c(seq(1, 99, by = 1), "Forbes 400")
df_quantiles$quantiles[100] <- c("Forbes 400")
df_quantiles$"Forbes 400" <- 0
df_quantiles$"Forbes 400"[100] <- min(subset(forbes_400$NETWORTH, forbes_400$YEAR == 2019))
df_quantiles$Thresholds <-
c(wtd.quantile(scf$NETWORTH, seq(.01, .99, by = .01), weight = scf$WGT), NA)
options(highcharter.theme = hc_theme_smpl(tooltip = list(valueDecimals = 0, thousandsSep = ',')))
lang <- getOption("highcharter.lang")
lang$numericSymbols <- c(" Thousand"," Million"," Billion"," Trillion")
lang$thousandsSep <- ","
options(highcharter.lang = lang)
figure1 <- highchart() %>%
hc_chart(type ="column",
barBorderWidth = 1) %>%
hc_title(text = "Figure 1: Wealth thresholds") %>%
hc_chart(zoomType = "x") %>%
hc_plotOptions(column = list(
dataLabels = list(enabled = FALSE),
stacking = "normal",
groupPadding = 0,
pointPadding = 0,
enableMouseTracking = TRUE)) %>%
hc_yAxis_multiples(
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = FALSE),
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = TRUE)) %>%
hc_xAxis(title = list(text = "Wealth Percentiles", style = list(fontSize = '13px')),
categories = df_quantiles$quantiles,
type = "category",
showFirstLabel = TRUE,
showLastLabel = TRUE
) %>%
hc_add_series(data = round(df_quantiles$Thresholds), name = "Wealth Thresholds", color = "grey", showInLegend = FALSE, visible = TRUE) %>%
hc_add_series(name = "<p style='font-size:15px; color:black'> Include Forbes 400 wealth threshold </p>", data = round(df_quantiles$`Forbes 400`), color = "red", showInLegend = TRUE, visible = FALSE,  fontSize = '200px') %>%
hc_legend(
align = "left",
verticalAlign = "top",
x = 75,
y = 0
) %>%
hc_exporting(enabled = TRUE) %>%
hc_tooltip(
useHTML = TRUE,
formatter = JS(
"
function(){
outHTML = '<b> Wealth Percentile: </b>' + this.x + '<br> <b> Threshold Value: </b>' + '$' + Number(this.y).toLocaleString()
return(outHTML)
}
"
),
shape = "callout", # Options are square, circle and callout
borderWidth = 1   # No border on the tooltip shape
)
saveWidget(figure1, "figure1.html", selfcontained=TRUE)
brew install pandoc
find_pandoc()
# Allows saving an HTML object to a file
install.packages("htmlwidgets", repos = "http://cran.us.r-project.org")
install.packages("htmlwidgets", repos = "http://cran.us.r-project.org")
library("htmlwidgets")
find_pandoc()
install.packages(pandoc)
install.packages("pandoc")
library("pandoc")
find_pandoc()
pandoc_activate()
pandoc_available()
pandoc_install()
pandoc_available()
pandoc_activate()
pandoc_available()
!pandoc_available()
saveWidget(figure1, "figure1.html", selfcontained=TRUE, title = "figure1")
find_pandoc()
y <- find_pandoc()
rmarkdown:::find_pandoc()
if(!pandoc_available()){
pandoc_install()
pandoc_activate()
}
pandoc_available()
if(pandoc_available()){
pandoc_install()
pandoc_activate()
}
library("rmarkdown")
figure1 <- highchart() %>%
hc_chart(type ="column",
barBorderWidth = 1) %>%
hc_title(text = "Figure 1: Wealth thresholds") %>%
hc_chart(zoomType = "x") %>%
hc_plotOptions(column = list(
dataLabels = list(enabled = FALSE),
stacking = "normal",
groupPadding = 0,
pointPadding = 0,
enableMouseTracking = TRUE)) %>%
hc_yAxis_multiples(
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = FALSE),
list(title = list(text = "Wealth in 2019 USD", style = list(fontSize = '13px')), opposite = TRUE)) %>%
hc_xAxis(title = list(text = "Wealth Percentiles", style = list(fontSize = '13px')),
categories = df_quantiles$quantiles,
type = "category",
showFirstLabel = TRUE,
showLastLabel = TRUE
) %>%
hc_add_series(data = round(df_quantiles$Thresholds), name = "Wealth Thresholds", color = "grey", showInLegend = FALSE, visible = TRUE) %>%
hc_add_series(name = "<p style='font-size:15px; color:black'> Include Forbes 400 wealth threshold </p>", data = round(df_quantiles$`Forbes 400`), color = "red", showInLegend = TRUE, visible = FALSE,  fontSize = '200px') %>%
hc_legend(
align = "left",
verticalAlign = "top",
x = 75,
y = 0
) %>%
hc_exporting(enabled = TRUE) %>%
hc_tooltip(
useHTML = TRUE,
formatter = JS(
"
function(){
outHTML = '<b> Wealth Percentile: </b>' + this.x + '<br> <b> Threshold Value: </b>' + '$' + Number(this.y).toLocaleString()
return(outHTML)
}
"
),
shape = "callout", # Options are square, circle and callout
borderWidth = 1   # No border on the tooltip shape
)
saveWidget(figure1, "figure1.html", selfcontained=TRUE, title = "figure1")
rmarkdown::find_pandoc()
library("rmarkdown")
save_html(figure1, "figure1.html", selfcontained=TRUE, title = "figure1")
save_html(figure1, "figure1.html")
if(FALSE) {
# scrape raw forbes 400 data for 2019
forbes_400_2019 <- cbind.data.frame(jsonlite::fromJSON(paste0("http://www.forbes.com/ajax/list/data?year=", 2019, "&uri=forbes-400", "&type=person")),year= 2019)
# rename variables
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "worth"] ="NETWORTH"
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "year"] ="YEAR"
# create sample weights
forbes_400_2019$WGT <- 1
# transform networth value
forbes_400_2019$NETWORTH <- forbes_400_2019$NETWORTH*1000000
# keep subset of variables
forbes_400_2019 <- forbes_400_2019[c("NETWORTH", "WGT", "YEAR")]
# drop if na values for networth
forbes_400_2019 <- na.omit(forbes_400_2019)
# write csv
write.csv(forbes_400_2019, "forbes_400_2019.csv", row.names = FALSE)
}
# NOTE: To scrape and clean raw Forbes 400 data for 2019, remove replace FALSE with TRUE
if(TRUE) {
# scrape raw forbes 400 data for 2019
forbes_400_2019 <- cbind.data.frame(jsonlite::fromJSON(paste0("http://www.forbes.com/ajax/list/data?year=", 2019, "&uri=forbes-400", "&type=person")),year= 2019)
# rename variables
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "worth"] ="NETWORTH"
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "year"] ="YEAR"
# create sample weights
forbes_400_2019$WGT <- 1
# transform networth value
forbes_400_2019$NETWORTH <- forbes_400_2019$NETWORTH*1000000
# keep subset of variables
forbes_400_2019 <- forbes_400_2019[c("NETWORTH", "WGT", "YEAR")]
# drop if na values for networth
forbes_400_2019 <- na.omit(forbes_400_2019)
# write csv
write.csv(forbes_400_2019, "forbes_400_2019.csv", row.names = FALSE)
}
# NOTE: To scrape and clean raw Forbes 400 data for 2019, remove replace FALSE with TRUE
if(FALSE) {
# scrape raw forbes 400 data for 2019
forbes_400_2019 <- cbind.data.frame(jsonlite::fromJSON(paste0("http://www.forbes.com/ajax/list/data?year=", 2019, "&uri=forbes-400", "&type=person")),year= 2019)
# rename variables
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "worth"] ="NETWORTH"
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "year"] ="YEAR"
# create sample weights
forbes_400_2019$WGT <- 1
# transform networth value
forbes_400_2019$NETWORTH <- forbes_400_2019$NETWORTH*1000000
# keep subset of variables
forbes_400_2019 <- forbes_400_2019[c("NETWORTH", "WGT", "YEAR")]
# drop if na values for networth
forbes_400_2019 <- na.omit(forbes_400_2019)
# write csv
write.csv(forbes_400_2019, "forbes_400_2019.csv", row.names = FALSE)
}
# NOTE: To scrape and clean raw Forbes 400 data for 2019, remove replace FALSE with TRUE
if(TRUE) {
# scrape raw forbes 400 data for 2019
forbes_400_2019 <- cbind.data.frame(jsonlite::fromJSON(paste0("http://www.forbes.com/ajax/list/data?year=", 2019, "&uri=forbes-400", "&type=person")),year= 2019)
# rename variables
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "worth"] ="NETWORTH"
colnames(forbes_400_2019)[colnames(forbes_400_2019) == "year"] ="YEAR"
# create sample weights
forbes_400_2019$WGT <- 1
# transform networth value
forbes_400_2019$NETWORTH <- forbes_400_2019$NETWORTH*1000000
# keep subset of variables
forbes_400_2019 <- forbes_400_2019[c("NETWORTH", "WGT", "YEAR")]
# drop if na values for networth
forbes_400_2019 <- na.omit(forbes_400_2019)
# write csv
write.csv(forbes_400_2019, "forbes_400_2019.csv", row.names = FALSE)
}
